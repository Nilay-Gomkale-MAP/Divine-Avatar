<!DOCTYPE html>
<html>
    <head>
        <script src="https://aframe.io/releases/1.7.0/aframe.min.js"></script>
        <script src="https://unpkg.com/aframe-orbit-controls@1.3.2/dist/aframe-orbit-controls.min.js"></script>
        <script src="https://cdn.jsdelivr.net/npm/aframe-extras@7.6.0/dist/aframe-extras.min.js"></script>
        <style>
            /* page background: slightly brighter spotlight, vertically centered, ~20% wider radius */
            body, html {
                margin: 0;
                overflow: hidden;
                height: 100%;
                /* center the spotlight vertically (50%), keep brighter inner spot and wider radius */
                background: radial-gradient(circle at 50% 50%, #4a4a4a 0%, #272727 30%, #000 72%) fixed;
            }

            /* let the A-Frame canvas be transparent so the gradient shows through */
            canvas {
                background: transparent !important;
                height: 100%;
            }

            /* hide default A-Frame enter-vr button (we use a custom button) */
            .a-enter-vr-button {
                display: none !important;
            }

            /* custom AR button: white fill, black text, bottom-center */
            #myEnterARButton {
                position: absolute;
                bottom: 32px;
                left: 50%;
                transform: translateX(-50%);
                background: #ffffff;
                color: #000000;
                border: none;
                padding: 16px 24px;
                border-radius: 4px;
                font-size: 16px;
                z-index: 10000;
                cursor: pointer;
                /* box-shadow: 0 4px 12px rgba(0,0,0,0.25); */
                -webkit-tap-highlight-color: transparent;
                text-decoration: none;
                font-family: Arial, Helvetica, sans-serif;
            }
            #myEnterVRButton:hover{
                background: #0000ff;
                color: #ffffff;
            }
            #exit-ar {
                position: absolute;
                right: 40px;
                top: 40px;
                background: rgba(127,127,127,0.25);
                color: white;
                border: 1px solid rgba(255,255,255,0.25);
                padding: 6px 8px;
                font-weight: bold;
            }
        </style>
    </head>

    <body>

        <!-- Overlay Section -->
        <div id="overlay">
            <span id="greeting">
              Hi, I'm the DOM Overlay
            </span>
            <button id="exit-ar">Exit AR</button>
          </div>

        <!-- Scene Setup Node -->
        <a-scene
            renderer="alpha: true;" 
            webxr="mode: ar; requiredFeatures: hit-test; referenceSpaceType: local; optionalFeatures: dom-overlay; overlayElement: #overlay"
            xr-mode-ui="enabled: true; XRMode: ar; enterARButton: #myEnterARButton; exitARButton: #myExitARButton;"
            vr-mode-ui="enabled: false"
            style="background: transparent;"
            ar-hit-test="target:#arOnly; enabled: true;">

            <!-- Importing Animated Model Asset -->
            <a-assets>
            <a-asset-item id="ARModel" src="Toy_Dino_animated.glb"></a-asset-item>
            </a-assets>

            <!-- Importing Highres Model Asset -->
            <a-assets>
                <a-asset-item id="pgModel" src="Toy_Dino_highres.glb"></a-asset-item>
            </a-assets>

            <!-- AR Model entity: start invisible so ar-hit-test can place/show it w/ Animation Mixer-->
            <a-entity
            id="arOnly"
            gltf-model="#ARModel"
            position="0 0 -1"
            scale="1.4 1.4 1.4"
            animation-mixer
            visible="false"
            ></a-entity>

            <!-- Web Page only model: No animations and should be set to disappear when changed to AR mode-->
            <a-entity
            id="pageOnly"
            gltf-model="#pgModel"
            position="0 0 -1"
            scale="1.4 1.4 1.4"
            ></a-entity>

            <!-- Custom AR Entry Buttons-->
            <a-entity id="myEnterARButton" href="#">Click to Start AR</a>
            <a-entity exit-ar-button="element: #exit-ar"></a-entity>
            

            <!-- LEARNING: 
            <a id="myExitARButton" href="#" style="display: none;">Exit AR Mode</a>

            Need to Use DOM Overlay to create an Exit button: 
            https://github.com/immersive-web/dom-overlays/blob/master/explainer.md 

            or

            Let's create an new 3D entity which is fixed in the top right corner of the screen,
            and when clicked, it will exit AR mode. => Tried and Failed to figure it out as it became tough to reliably place the Exit button in the top right corner
            -->
            
            <!-- Camera with orbit controls for desktop and non-AR mode -->
            <a-entity
            camera
            look-controls="enabled: false"
            orbit-controls="target: 0 0.25 -1; enableZoom: true; enablePan: false; initialPosition: 0 0.5 -0.2; rotateSpeed: 1; zoomSpeed: 1.2; minDistance: 0.25; maxDistance: 2.5; autoRotate: true"
            ></a-entity>

            <!-- IDEA WHILE TESTING:
            We can parent a fixed image to the camera like done above to make some creative frames that make enhance the experience, 
            this way we can take advantage of fixed elements to insert text, clues and more to create an interesting experience
            -->

            <!-- Basic lighting -->
            <a-entity light="type: ambient; intensity: 0.8"></a-entity>
            <a-entity light="type: directional; intensity: 1" position="1 2 1"></a-entity>
        </a-scene>
    </body>
    
    <script>
        // Query Selectors and initial setup
        const scene = document.querySelector('a-scene');
        const camera = scene.querySelector('[camera]');
        const arModel = document.querySelector('#arOnly');
        const pageModel = document.querySelector('#pageOnly')
        const entryBtn = document.getElementById('myEnterARButton');

        // store initial transform so we can restore on exit-vr
        const initPosAttr = arModel.getAttribute('position') || { x: 0, y: 0, z: -1 };
        const initialPosition = new THREE.Vector3(initPosAttr.x, initPosAttr.y, initPosAttr.z);
        const initialQuaternion = arModel.object3D.quaternion.clone();

        // Create a simple white reticle (ring)
        const reticle = document.createElement('a-entity');
        reticle.setAttribute('id', 'reticle');
        reticle.setAttribute('geometry', 'primitive: ring; radiusInner: 0.03; radiusOuter: 0.05;');
        reticle.setAttribute('material', 'color: #ffffff; shader: flat; opacity: 0.95;');
        reticle.setAttribute('rotation', '-90 0 0'); // lay flat on detected surface
        reticle.setAttribute('visible', 'false');
        scene.appendChild(reticle);

        // WebXR hit-test variables
        let xrSession = null;
        let hitTestSource = null;
        let localReferenceSpace = null;
        let placed = false;
        let onSelectHandler = null;

        async function startHitTest(session) {
            localReferenceSpace = await session.requestReferenceSpace('local');
            const viewerSpace = await session.requestReferenceSpace('viewer');
            hitTestSource = await session.requestHitTestSource({ space: viewerSpace });
            session.requestAnimationFrame(onXRFrame);
        }

        function stopHitTest() {
            if (hitTestSource) {
                hitTestSource.cancel && hitTestSource.cancel();
                hitTestSource = null;
            }
            localReferenceSpace = null;
            xrSession = null;
            reticle.setAttribute('visible', 'false');
        }

        function onXRFrame(time, xrFrame) {
            const session = xrFrame.session;
            session.requestAnimationFrame(onXRFrame);

            if (!hitTestSource || placed) return;

            const hitResults = xrFrame.getHitTestResults(hitTestSource);
            if (hitResults.length > 0) {
                const hit = hitResults[0];
                const pose = hit.getPose(localReferenceSpace);
                if (pose) {
                    const pos = pose.transform.position;
                    const ori = pose.transform.orientation;
                    reticle.object3D.position.set(pos.x, pos.y, pos.z);
                    reticle.object3D.quaternion.set(ori.x, ori.y, ori.z, ori.w);
                    reticle.setAttribute('visible', 'true');
                } else {
                    reticle.setAttribute('visible', 'false');
                }
            } else {
                reticle.setAttribute('visible', 'false');
            }
        }

        // Placing the model using the Reticle Data
        function placeModelAtReticle() {
            if (!reticle.getAttribute('visible')) return;
            arModel.object3D.position.copy(reticle.object3D.position);
            arModel.object3D.quaternion.copy(reticle.object3D.quaternion);
            arModel.setAttribute('visible', 'true');
        }

        // Enter AR: hide the desktop model and start hit test for placement
        scene.addEventListener('enter-vr', async () => {
            if (!scene.is('ar-mode')) return;

            // prepare for AR placement
            placed = false;
            arModel.setAttribute('visible', 'false');
            pageModel.setAttribute('visible', 'false');
            camera.setAttribute('look-controls', 'enabled', true);
            camera.setAttribute('orbit-controls', 'enabled', false);

            xrSession = scene.renderer.xr.getSession();
            if (!xrSession) return;

            // single-use select handler: place once, then stop hit test
            onSelectHandler = () => {
                if (placed) return;
                placeModelAtReticle();
                placed = true;
                // cleanup hit test and hide reticle after placement
                stopHitTest();
                if (xrSession && onSelectHandler) {
                    xrSession.removeEventListener('select', onSelectHandler);
                }
            };
            xrSession.addEventListener('select', onSelectHandler);

            xrSession.addEventListener('end', () => {
                stopHitTest();
            });

            try {
                await startHitTest(xrSession);
            } catch (err) {
                console.warn('Hit test start failed:', err);
            }
            entryBtn.style.display = 'none'; // hide entry button
        });

        //Code borrowed from Boilerplate template: https://github.com/aframevr/aframe/blob/master/examples/boilerplate/webxr-dom-overlay/index.html
        AFRAME.registerComponent('exit-ar-button', {
            schema: {
                element: {type: 'selector'}
            },
            init: function () {
            this.data.element.addEventListener('click', ev => {
                this.el.sceneEl.renderer.xr.getSession().end();
            });
            }
        });

        // Exit AR: restore desktop behaviour and reset model to initial transform
        scene.addEventListener('exit-vr', () => {
            placed = false;
            pageModel.setAttribute('visible', 'true');
            arModel.setAttribute('visible', 'false');
            exitBtn.setAttribute('visible', 'false');

            // restore default position & rotation
            arModel.object3D.position.copy(initialPosition);
            arModel.object3D.quaternion.copy(initialQuaternion);
            camera.setAttribute('look-controls', 'enabled', false);
            camera.setAttribute('orbit-controls', 'enabled', true);
            camera.setAttribute('initialPosition', '0 0.5 -0.2')
            stopHitTest();

            entryBtn.style.display = 'block'; // Show entry button
        });
    </script>
 </html>
