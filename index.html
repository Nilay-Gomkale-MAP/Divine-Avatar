<!DOCTYPE html>
<html>
    <head>
        <script src="https://aframe.io/releases/1.7.0/aframe.min.js"></script>
        <script src="https://unpkg.com/aframe-orbit-controls@1.3.2/dist/aframe-orbit-controls.min.js"></script>
        <script src="https://cdn.jsdelivr.net/npm/aframe-extras@7.6.0/dist/aframe-extras.min.js"></script>
        <style>
            /* page background: radial "spotlight" fading to black */
            body, html {
                margin: 0;
                overflow: hidden;
                height: 100%;
                background: radial-gradient(circle at 50% 25%, #2a2a2a 0%, #161616 25%, #000 60%) fixed;
            }

            /* let the A-Frame canvas be transparent so the gradient shows through */
            canvas {
                background: transparent !important;
                height: 100%;
            }

            /* move the A-Frame XR/AR button to bottom center */
            .a-enter-vr-button,
            .a-enter-vr-button__button,
            .a-enter-vr-button button {
                position: fixed !important;
                bottom: 20px !important;
                left: 50% !important;
                transform: translateX(-50%) !important;
                z-index: 9999 !important;
            }
        </style>
    </head>

    <body>
        <a-scene
            renderer="alpha: true;" 
            webxr="mode: ar; requiredFeatures: hit-test; referenceSpaceType: local;"
            xr-mode-ui="enabled: true; XRMode: ar"
            vr-mode-ui="enabled: false"
            style="background: transparent;"
            ar-hit-test="target:#vahan; src:Reticle_circle.png; enabled: true;"
        >
        <a-assets>
          <!-- use relative path -->
          <a-asset-item id="ARModel" src="Toy_Dino.glb"></a-asset-item>
        </a-assets>

        <!-- Model entity: start invisible so ar-hit-test can place/show it w/ Animation Mixer-->
        <a-entity
          id="vahan"
          gltf-model="#ARModel"
          position="0 0 -1"
          scale="1.4 1.4 1.4"
          animation-mixer
          visible="false"
        ></a-entity>

        <!-- Camera with orbit controls for desktop and non-AR mode -->
        <a-entity 
        camera 
        look-controls="enabled: false"
        orbit-controls="target: 0 0 -1; enableZoom: true; enablePan: false; initialPosition: 0 0 0.6; rotateSpeed: 6; zoomSpeed: 1.2"
        ></a-entity>

        <!-- Basic lighting -->
        <a-entity light="type: ambient; intensity: 0.8"></a-entity>
        <a-entity light="type: directional; intensity: 1" position="1 2 1"></a-entity>

        <!-- Sky background -->
        <!-- <a-sky color="#ECECEC"></a-sky> -->
        </a-scene>
    </body>
    <script>
        const scene = document.querySelector('a-scene');
        const camera = scene.querySelector('[camera]');
        const model = document.querySelector('#vahan');

        // store initial transform so we can restore on exit-vr
        const initPosAttr = model.getAttribute('position') || { x: 0, y: 0, z: -1 };
        const initialPosition = new THREE.Vector3(initPosAttr.x, initPosAttr.y, initPosAttr.z);
        const initialQuaternion = model.object3D.quaternion.clone();

        // show model on normal (non-AR) page load
        model.setAttribute('visible', 'true');

        // Create a simple white reticle (ring)
        const reticle = document.createElement('a-entity');
        reticle.setAttribute('id', 'reticle');
        reticle.setAttribute('geometry', 'primitive: ring; radiusInner: 0.03; radiusOuter: 0.05;');
        reticle.setAttribute('material', 'color: #ffffff; shader: flat; opacity: 0.95;');
        reticle.setAttribute('rotation', '-90 0 0'); // lay flat on detected surface
        reticle.setAttribute('visible', 'false');
        scene.appendChild(reticle);

        // WebXR hit-test variables
        let xrSession = null;
        let hitTestSource = null;
        let localReferenceSpace = null;
        let placed = false;
        let onSelectHandler = null;

        async function startHitTest(session) {
            localReferenceSpace = await session.requestReferenceSpace('local');
            const viewerSpace = await session.requestReferenceSpace('viewer');
            hitTestSource = await session.requestHitTestSource({ space: viewerSpace });
            session.requestAnimationFrame(onXRFrame);
        }

        function stopHitTest() {
            if (hitTestSource) {
                hitTestSource.cancel && hitTestSource.cancel();
                hitTestSource = null;
            }
            localReferenceSpace = null;
            xrSession = null;
            reticle.setAttribute('visible', 'false');
        }

        function onXRFrame(time, xrFrame) {
            const session = xrFrame.session;
            session.requestAnimationFrame(onXRFrame);

            if (!hitTestSource || placed) return;

            const hitResults = xrFrame.getHitTestResults(hitTestSource);
            if (hitResults.length > 0) {
                const hit = hitResults[0];
                const pose = hit.getPose(localReferenceSpace);
                if (pose) {
                    const pos = pose.transform.position;
                    const ori = pose.transform.orientation;
                    reticle.object3D.position.set(pos.x, pos.y, pos.z);
                    reticle.object3D.quaternion.set(ori.x, ori.y, ori.z, ori.w);
                    reticle.setAttribute('visible', 'true');
                } else {
                    reticle.setAttribute('visible', 'false');
                }
            } else {
                reticle.setAttribute('visible', 'false');
            }
        }

        function placeModelAtReticle() {
            if (!reticle.getAttribute('visible')) return;
            model.object3D.position.copy(reticle.object3D.position);
            model.object3D.quaternion.copy(reticle.object3D.quaternion);
            model.setAttribute('visible', 'true');
        }

        // Enter AR: hide the desktop model and start hit test for placement
        scene.addEventListener('enter-vr', async () => {
            if (!scene.is('ar-mode')) return;

            // prepare for AR placement
            placed = false;
            model.setAttribute('visible', 'false');
            camera.setAttribute('look-controls', 'enabled', true);
            camera.setAttribute('orbit-controls', 'enabled', false);

            xrSession = scene.renderer.xr.getSession();
            if (!xrSession) return;

            // single-use select handler: place once, then stop hit test
            onSelectHandler = () => {
                if (placed) return;
                placeModelAtReticle();
                placed = true;
                // cleanup hit test and hide reticle after placement
                stopHitTest();
                if (xrSession && onSelectHandler) {
                    xrSession.removeEventListener('select', onSelectHandler);
                }
            };
            xrSession.addEventListener('select', onSelectHandler);

            xrSession.addEventListener('end', () => {
                stopHitTest();
            });

            try {
                await startHitTest(xrSession);
            } catch (err) {
                console.warn('Hit test start failed:', err);
            }
        });

        // Exit AR: restore desktop behaviour and reset model to initial transform
        scene.addEventListener('exit-vr', () => {
            placed = false;
            model.setAttribute('visible', 'true');
            // restore default position & rotation
            model.object3D.position.copy(initialPosition);
            model.object3D.quaternion.copy(initialQuaternion);
            camera.setAttribute('look-controls', 'enabled', false);
            camera.setAttribute('orbit-controls', 'enabled', true);
            stopHitTest();
        });
    </script>
</html>
